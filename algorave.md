# algorave

# Description

Category: Rev

![image.png](image.png)

# Overview

The challenge provides a JavaScript code snippet running on the **Strudel** platform (a live coding environment for music based on TidalCycles).

**Initial Observation:**
When the Play button is hit, the code attempts to generate audio but stops almost immediately (displaying only the start of a pattern like `hxp{`) before the browser freezes or crashes due to high resource consumption.

**Goal:**
Optimize the provided code to prevent the crash, allowing the script to fully render the visual pattern on the Piano Roll, revealing the hidden flag.

# Analysis

### Code Logic

The core of the challenge lies in the `rand` signal generated by a recursive function `f(k)`:

```c
rand = signal(t => {
  const f = k => {
    // Base case (stopping condition)
    if (silence._steps.gte(k)) return k;
    
    // Recursive call branch 1
    const a = ... + f(id(k-silence._steps)) + ...;
    
    // Recursive call branch 2
    return ... + f(constant(k - ...));
  };
  return f(Math.floor(t));
});
```

**Root Cause Analysis**
The freeze is caused by **Algorithmic Complexity**:
1. **Exponential Recursion:** The function `f(k)` calls itself multiple times within a single execution step. This creates a recursion tree with a complexity of roughly O(2^n).
2. **Redundant Calculations:** The same values for `f(k)` are recalculated thousands of times unnecessarily.
3. **Resource Exhaustion:** As `t` (time) increases to render the subsequent parts of the flag, the recursion depth explodes, causing a CPU spike and eventually a Stack Overflow, freezing the browser.

# Sol

To fix this, I apply **Dynamic Programming**, specifically **Memorization**.
**The Strategy:**

- Initialize a global cache object (`memo`)
- Before performing the expensive recursive calculation for `f(k)`, check if `k` exists in the cache
- **If cached:** Return the value immediately (O(1)).
- **If not cached:** Calculate the result, store it in `memo`, and then return it.

This reduces the time complexity from **Exponential** (O(2^n)) to **Linear** (O(n)), allowing the code to run smoothly in real-time.

## Exploit Script

Here is the optimized code used to solve the challenge:

```c
// [DATA] The 'notes' array is kept as provided in the challenge
const notes = [note("[c4,f#4]"), ... ]; 

// [FIX] 1. Initialize a global cache object
const memo = {}; 

rand = signal(t => {
  const f = k => {
    // [FIX] 2. Check Cache (Memoization Check)
    if (memo[k] !== undefined) return memo[k];

    // Base case logic
    if (silence._steps.gte(k)) return k;

    // Complex recursive calculation (kept original)
    const a = cycleToSeconds(f(id(k-silence._steps)) + scramble(notes[Math.floor(t)]).length, midi2note(nothing.query.length)[Number(notes[5]._steps.n)]);
    
    const result = _mod(a + parseNumeral(notes[a % notes.length]._steps.d) * Number(notes[duck.length]._steps.n) + f(constant(k - parseFractional(notes[4]._steps.n), getFrequency)), notes.length);

    // [FIX] 3. Store result in Cache before returning
    memo[k] = result;
    
    return result;
  };

  return f(Math.floor(t));
});

// [RENDER] Visualization
// .fast(10) compresses the time axis so the notes form legible characters
squeeze(rand.segment(Number(notes[0]._steps.n)),notes,).fast(10).s("piano").pianoroll({fold:+!silence._Pattern,minMidi:58,maxMidi:67,autorange:+!nothing._Pattern,});
```

# Result

Upon running the patched script:

1. The browser no longer hangs.
2. The Strudel engine renders the notes onto the Piano Roll.
3. Thanks to the `.fast(10)` function, the notes are compressed together, forming a clear visual pattern (**Visual Steganography**).



Flag â†’ `hxp{let's_compose_a_cl4ss1cal_pi3ce_of_algor4v3}`
